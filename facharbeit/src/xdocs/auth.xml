<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">
<document>
  <header>
    <title>Authentifizierung</title>
  </header>
  <body>
    <section id="all">
      <title>Aufbau</title>
      <p>
        Die Authentifizierung bei MRBS ist sehr gut durchdachtes, modulares 
        System, das in 2 Bereiche aufgeteilt ist: Datenentgebennahme 
        (Session-Module) und Datenüberprüfung(Auth-Module). Ich habe im 
        folgenden UML-Diagram den Systemaufbau nachmodelliert, hierzu muss man 
        beachten, dass das UML-Diagram von einer objektorientierten Achitektur 
        ausgeht, MRBS jedoch lediglich Funktionen aus dem Modul einbindet. Im 
        Folgenden habe ich Auth/Ext und Session/PHP als Beispiel-Implementierungen
        der jeweiligen Schnittstellen genommen.
      </p>
      <figure src="images/auth-uml.jpg" alt="UML-Diagramm zur Authentifikation" />
    </section>
    <section id="hsg-install">
      <title>HSG Installation</title>
      <p>
        Am HSG wird die Authentifikation nicht von Schoorbs geregelt, sondern 
        eine Ebene höher vom Apache Webserver. Um Schoorbs mitzuteilen, dass es 
        nicht für die Authentifizierung zuständig ist, aktiviert man das Modul
        Auth/None. Der Apache Webserver teilt uns den Nuternamen, bei
        erfolgreicher Authentifikation, über die Umgebungsvariable REMOTE_USER 
        mit.
      </p>
      <p><strong>Auth/None</strong></p>
      <p>
        Das Auth/None-Modul akzeptiert jeden Nutzernamen und jedes beliebige
        Passwort dazu als gültige Kombination. Dieses ist nicht mehr als echte
        Authentifizierung anzusehen, eher ist dieses Modul gedacht, Schoorbs
        vorzutäuschen, man würde die Authentifikation selbst erledigen, jedoch
        sind die Eingabewerte von einer höheren Ebene, in diesem Fall vom Apache
        Webserver, schon überprüft worden. Ungültige 
        Nutzer/Passwort-Kombinationen werden überhaupt nicht an Schoorbs 
        weitergeleitet. 
      </p>
      <p>
        Dieses Verhalten wird durch die Implementation der 
        Funktion <code>authValidateUser</code> erzeugt, welche in diesem Modul 
        lediglich aus der Zeile <code>return 1;</code> besteht. Lediglich in der 
        Implementierung von <code>authGetUserLevel</code> befindet sich Logik. 
        Ist kein Nutzername gestetzt, gilt dies als nicht angemeldet, was am
        HSG nicht passieren kann, da dort lediglich die bereits 
        authentifizierten Nutzer überhaupt die Schoorbs-Installation erreichen
        können. Sollte der Nutzername in der Liste der Administratoren 
        eingetragen sein, so bekommt dieser Nutzer Admininistrationsrechte, ist
        er nicht in dieser Liste eingetragen, bekommt er die Rechte eines 
        normalen Nutzers. Die in dieser Funktion vorkommende Logik findet man in
        nahezu allen Auth-Modulen wieder, weshalb in zukünftigen Versionen von 
        Schoorbs eine Generalisierung der Logik möglich wäre, jedoch habe ich
        dies nicht gemacht um die Auth-Schnittstelle abwärtskompatibel zu MRBS 
        zu halten.
      </p>
      <p><strong>Session/Remote_User</strong></p>
      <p>
        <!-- Was macht es? -->
        Das Session/Remote_User-Modul nutzt als Quelle für den Nutzernamen die 
        Umgebungsvariable <code>REMOTE_USER</code>, welche man in PHP per 
        <code>$_SERVER['REMOTE_USER']</code> auslesen kann. Am HSG fragt der 
        Apache per HTTP-Authentifikation die Nutzername/Passwort-Kombination ab,
        die er dann wieder mit der eingestellten Nutzerdatenbank abgleicht. Nur
        wenn diese Kombination gültig ist, wird die HTTP-Anfrage an Schoorbs 
        weitergeleitet, d.h. Anfragen mit falscher Nutzername/Passwort-Kombination
        rufen überhaupt keinen Programm-Code auf, weshalb Angreifer nur aus dem 
        Kreis der Nutzer mit Account kommen können, dritte ohne 
        Authentifizierungsdaten werden schon vom Apache abgewiesen. Weiterhin 
        wird auch nur der Nutzername, jedoch nicht das Passwort, an Schoorbs 
        weitergeleitet, so dass man auch nicht durch Modifizieren des Codes als z.B.
        Programmadminstrator, d.h. jemand der den Programmcode verändern kann, 
        die Passwörter ausspähen kann.
      </p>
      <p>
        <!-- Technisch -->
        Ähnlich wie beim Auth/None-Modul beinhaltet das Session/Remote_User-Modul
        nahezu keine Logik. Die Funktion <code>getUserName</code> gibt z.B. den
        Nutzernamen zurück, wenn er gesetzt ist, ansonsten null. 
        <code>authGet</code> beinhaltet sogar überhaupt keinen Code und stellt 
        nur die Schnittstelle bereit. <code>PrintLoginBox</code> zeigt entweder 
        den Nutzernamen an oder schmeisst einen fatalen Fehler, wenn der 
        Nutzername nicht gesetzt ist.
      </p>
    </section>
  </body>
</document>
