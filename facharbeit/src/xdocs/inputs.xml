<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">
<document>
  <header>
    <title>Eingabeverarbeitung</title>
  </header>
  <body>
    <section id="short">
      <title>Grundlegendes</title>
      <note>
        Dieses Kapitel bezieht sich auf die Eingabeverarbeitung von MRBS und 
        den dazu ergriffenen Gegenmaßnahmen in Schoorbs. Die erwähnten
        Schwachstellen sind in Schoorbs nicht mehr vorhanden, jedoch in
        <strong>allen</strong> im Umlauf befindenen, neueren MRBS-Versionen.
      </note>
      <p>
         Die Eingabeverarbeitung ist die größte Schwachstelle vieler 
         PHP-Programme, so auch von MRBS[1]. Oftmals werden Parameter direkt 
         vom Benutzer unverändert in SQL-Befehle übernommen(siehe [2]), dies 
         wird SQL-Injection[3] genannt und kann genutzt werden um beliebige 
         Kommandos auf der Datenbank auszuführen. An manchen Stellen werden auch,
         oftmals nicht erwartet, Benutzereingaben direkt wieder ausgeben, so 
         kann man Nutzer mit gefälschten Links auf gefälschte Seiten locken, 
         die aber unter der richtigen URL aufgerufen werden(Bsp: siehe [4]), 
         solche Schwachstellen werden mit XSS beschrieben[5]. Dies wird häufig 
         durch die Nutzung von grab_globals.inc(wird später unter XSS-Lösung 
         beschrieben) verursacht, da so keine Trennung mehr von internen und 
         externen($_REQUEST, $_GET, …) Variabeln möglich ist. Diese Art von 
         Sicherheitslücken ist heutzutage die Grundlage von Phishing-Attacken[6]. 
         Für den Benutzer unsichtbar, aber für den stabilen Betrieb der Software
         sehr schädlich sind Endlosschleifen, bei der ein PHP-Script meistens 
         mit der voreingestellten max_execution_time[7] von 30s die CPU
         vollständig belastet. Würde jemand nun mehrere (>20) Anfragen alle 
         20-30s an den Server schicken, so wäre dieser überlastet, müsste 
         andere Anfragen zurückstellen, was zu mehr Speicherverbruauch führt, 
         wobei der Server(z.B. Apache) irgendwann mehr Speicher bräuchte als 
         man ihm zur Verfügung stellen könnte und daraufhin abstürtzt, vor 
         allem auf älteren Windows-PCs(95 und 98) führte dies auch öfters zu 
         einem Abstürtzen des Betriebsystems. Die Art von Sicherheitslücke 
         hat an sich keinen eigenen Namen, die Methode sie auszunutzen wird 
         aber “DoS-Attacke“[8] genannt.
      </p>
      <p>
        Es darf jedoch nicht ganz verschwiegen werden, dass Ansätze von 
        Eingabeüberptüfung schon vorhanden sind, so wird z.B. wenn eine 
        Komponente(Tag, Monat, Jahr) eines Datums fehlt, das Datum auf den 
        heutigen Tag gestetzt. Auch andere Werte, z.B. die Variable $area, 
        wird, wenn nicht gestetzt, mit dem Defaultwert initialisiert(siehe [9]). 
        Jedoch sind diese Methoden zu simpel gehalten und bieten kaum Sicherheit, 
        im folgenden möchte ich zeigen, wie ich diese 3 Schwachstellen 
        ausgebessert habe.
      </p>
    </section>
    <section id="sql-injection">
      <title>SQL-Injection-Lösung</title>
      <p>
        Zuerst werde ich, wie allen folgenden Lösungen, zeigen wie man die 
        Schwachstelle ausnutzt. Da wir uns mit Eingabeparametern beschäftigen, 
        muss man nur eine spezielle geformte URL erstellen um die Schwachstelle 
        auszunutzen. Als Beispiel für den Angriff auf die Datenbank nehme ich mir:
      </p>
      <source>$sql = "SELECT $tbl_room.id, start_time, end_time, name, $tbl_entry.id,
        type, $tbl_entry.description
        FROM $tbl_entry, $tbl_room
        WHERE $tbl_entry.room_id = $tbl_room.id
        AND area_id = $area
        AND start_time &lt;= $pm7 AND end_time > $am7";</source>
      <p>
        Die Variable <code>$area</code> wird hier unverändert aus dem Query-Teil 
        der URL übernommen, das heißt man kann hier auch einen beliebigen String 
        angeben, also auch Teile eines SQL-Befehls. Nehmen wir mal an, wir haben 
        keinen Account, möchten aber trotzdem eine Buchung vornehmen, also 
        beenden wir erst mal den Teil des SQL-Befehls, der vor der Variable ist.
        So nehmen wir als Wert für die <code>area_id</code>, die abgefragt werden 
        soll '1' und beenden den Befehl mit ';', da dies aber ein HTTP-Parameter 
        ist, muss ';' als '%3B' geschrieben werden, so haben wir schon 
        <code>area=1%3B</code>. Als nächstes bauen wir uns den INSERT-Befehl, 
        da man normalerweise nicht weiß, wie die Tabellen bei der jeweiligen 
        MRBS Installation heißen, müsste man jetzt einfach raten, ich nehme 
        hier den Standardnamen 'mrbs_entry', meinen Benutzer habe ich '5' genannt,
        da ' von PHP automatisch maskiert werden und ich diese für Strings 
        brauche(5 habe ich als Integer eingebaut), als Befehl nutze ich dann folgenden:
      </p>
      <source>INSERT INTO mrbs_entry (start_time, end_time, entry_type,
        repeat_id, room_id, create_by, name) VALUES (1165662420, 
        1165662480, 0, 0, 1, 5, 5);</source>
      <p>
        Als HTTP-Parameter kodiert sieht dieser dann folgend aus:
      </p>
      <source>INSERT%20INTO%20mrbs_entry%20%28start_time%2C%20end_time
%2C%20entry_type%2C%20repeat_id%2C%20room_id%2C%20create_by
%2C%20name%29%20VALUES%20%281165662420%2C%201165662480
%2C%200%2C%200%2C%201%2C%205%2C%205%29%3B</source>
      <p>
        Nun müssen wir noch sicherstellen, dass der andere Teil des normalen 
        Befehls richtig ausgeführt wird, so erzeugen wir kann simpel mit
      </p>
      <source>SELECT * FROM mrbs_entry WHERE true 
//... hier kommt dann der Rest des normalen Befehls ...</source>
      <p>
        Alle diese 3 Teile packt man nun zu einem Parameter zusammen und erhält 
        folgende Beispiel-URL (Zeilenumbrüche sollten ignoriert werden):
      </p>
      <source>http://mrbs/day.php?day=10&amp;month=04&amp;year=2007&amp;area=1%3BINSERT
%20INTO%20mrbs_entry%20%28start_time%2C%20end_time
%2C%20entry_type%2C%20repeat_id%2C%20room_id%2C%20create_by
%2C%20name%29%20VALUES%20%281165662420%2C%201165662480%2C%200
%2C%200%2C%201%2C%205%2C%205%29%3BSELECT%20*%20FROM%20mrbs_entry
%20WHERE%20true%20</source>
      <p>
        SQL-Injections sind die wohl einfach abzusichersten Lücken, da man hier 
        nicht jede einzelne Variablen auf bestimmte Vorraussetzungen prüfen 
        muss(wodurch man pro Eingabeparameter eine Funktion bräuchte). Man muss 
        nur die Variable maskieren, so dass sie nur als einzelner Parameter 
        eines SQL-Befehl angesehen wird. Dies kann man mit den Funktionen 
        <code>mysql_real_escape_string</code>[10] und 
        <code>pg_escape_string</code>[11] machen, da MRBS aber eine einheitliche
        Datenbankschnittstelle hat und die beiden Funktionen nicht identisch 
        sind, habe ich sie in der Funktion <code>sql_escape_arg</code> gekapselt.
        Diese Änderung im Prinzip wirkt sich nur minimal auf den Quelltext aus, 
        aber extrem auf die Sicherheit eines PHP-Programms, meinen 
        Beispiel-SQL-Befehl von oben sieht dann wie folgend aus:
      </p>
      <source>$sql = "SELECT $tbl_room.id, start_time, end_time, name, $tbl_entry.id,
         type, $tbl_entry.description, $tbl_entry.create_by
         FROM $tbl_entry, $tbl_room WHERE   
         $tbl_entry.room_id = $tbl_room.id AND area_id = "
         .sql_escape_arg($area) // Absicherung gegen SQL-Injection
         ." AND start_time &lt;= $pm7 AND end_time &gt; $am7";</source>
    </section>
    <section id="xss">
      <title>XSS(Cross-Site-Scripting)-Lösung</title>
      <p>
        Als Grundlage des Beispiels nehme ich den Code von [4], dieses Komanndo 
        befindet sich in der Funktion <code>PrintLogonBox()</code>, die Variable 
        <code>$user_list_link</code> wird per <code>global</code> eingebunden.
      </p>
      <source>if (isset($user_list_link)) print "
	     &lt;br&gt;
	     &lt;A href=\"$user_list_link\"&gt;" . get_vocab('user_list') . "&lt;/A&gt;&lt;br&gt;\n";</source>
      <p>
        Eigentlich ist gedacht, sie zu nutzen um einen Link zu einer Liste aller 
        Benutzer bereitzustellen, wenn diese Variable nicht gesetzt ist, dann wird 
        auch der HTML-Code nicht angezeigt, da jedoch MRBS grab_globals.inc 
        benutzt, können wir jede beliebige globale Variable belegen. Die Datei 
        grab_globals.inc ist an sich der Hauptverursacher für die Sicherheitslücken 
        in MRBS, da es die Eigenschaft register_globals=on auch auf Platformen 
        simuliert, wo diese aus Sicherheitsgründen abgeschaltet ist. Auf 
        register_globals, also das Einbinden von Variablen aus den Arrays 
        $_SERVER, $_ENV, $_GET, $_POST und $_POST als normale Variablen, 
        basieren viele der Attacken gegen PHP-Scripte, da viele Programmierer 
        nicht auf die korrekte Initialisierung ihrer Variabeln achten. Um 
        solchen Programmierfehlern vorzubeugen wurde auch beschlossen, 
        register_globals vollständig aus PHP zu entfernen(in der kommenden 
        Version 6). Zurück zu meinem Beispiel: Wir möchten nun also einen 
        Link anzeigen lassen, um z.B. Besucher auf seine Homepage zu locken, 
        zwar steht in diesem Fall immer noch „Benutzerliste“ als Linkname, 
        jedoch die Adresse können wir frei bestimmen. Nehmen wir als Beispiel 
        meine Homepage <code>http://xhochy.org</code> , wir maskieren diese für HTTP 
        <code>http%3A//xhochy.org</code> und hängen sie an die normale 
        URL an(als Wert für den Parameter <code>user_list_link</code>). So 
        erhalten wir folgende URL, bei der rechts oben in der Loginbox ein Link
        mit der Aufschrift 'Benutzerliste' auf meine Homepage zeigt.
      </p>
      <source>http://mrbs/day.php?user_list_link=http%3A//xhochy.org</source>
      <p>
        Um diesen Problem zu entgehen, habe ich die grab_globals.inc aus nahezu 
        allen zum Betrieb nötigen Dateien entfernt und die betreffenden Variablen, 
        die der Benutzer eingeben solte entweder direkt aus <code>$_REQUEST</code> 
        geholt oder eine eigene Funktion erstellt um diese zu parsen(siehe DoS-Lösung).
        Durch dieses Vorgehen muss man an der obigen Funktionen nichts ändern, 
        andere Variablen wie z.B. <code>$year</code> müssen aber zuerst manuell 
        initialisert werden:
      </p>
      <source>$year = intval($_REQUEST['year']);</source>
    </section>
    <section id="dos">
      <title>DoS(Denial of Service)-Lösung</title>
      <p>
        Bei DoS-Angriffen reicht normalerweise nie ein Seitenaufruf auf, da 
        Webserver eigentlich normalerweise ca. 100 Seitenaufrufe pro Sekunde 
        verkraften sollten, wenn man jedoch mehrere gleichzeitig laufen lässt, 
        die immer mehr Arbeitsspeicher brauchen und die CPU voll auslasten, 
        bekommt der Webserver dann doch irgendwann Probleme die Anfragen zu 
        verwalten. Wird jetzt die Seite, die eine Endlosschleife beinhaltet 
        mehrmals aufgrufen, wird irgendwann so viel Speicher belegt sein, 
        dass der Webserver zum Verarbeiten der neuen Anfragen keinen 
        Arbeitsspeicher mehr bekommen kann und so abstürtzt. PHP hat hier mit 
        <code>max_execution_time</code> sogar einen Schutz eingebaut, jedoch 
        ist die Laufzeit von 30 Sekunden hier ausreichend um den Server 
        abstürzen zu lassen. Mein Windows-Apache-Testrechner brauchte ca. 3 min 
        bis er eingeforen war. Das Beheben dieser Sicherheitslücke ist leider 
        nicht sehr einfach, da man jeden Eingabeparameter zunächst überprüfen 
        muss, ob er auch in einem Bereich ist, der von Parameter zu Parameter 
        variiert. Als Beispiel möchte ich hier zeigen, wie ich die Eingaben 
        von Tag, Monat und Jahr überprüft habe und wieso man sie überhaupt 
        überprüfen muss. MRBS prüft bei einenm Aufruf einer Seite automatisch, 
        ob der Tag zu dem genannten Monat und Jahr passt und subtrahiert ihn 
        gegebenenfalls mit folgender Schleife:
      </p>
      <source>while (!checkdate(intval($month), intval($day), 
      intval($year)))
   $day--;</source>
      <p>
        Sollte nun <code>$day</code> &lt; 1 sein, so würde es ca 2<sup>32</sup>-30 
        Durchläufe brauchen, bis das Datum wieder richtig ist, da PHP aber auch 
        die Integervariable gegenbenfalls in eine float-Variable umwandelt 
        falls sie -INT_MAX unterschreitet, dauert dies noch deutlich länger 
        bzw wird irgenwann sinnlos, wenn der Unterschied zwischen der jetzigen 
        und dann folgenden float-Zahl größer als 1 ist, woraufhin sich 
        <code>$day</code> nicht mehr verändert und eine Endlosschleife 
        entstanden ist. Ich habe nun für jede zu überprüfende Variable im 
        Ornder schoorbs-includes/input/ eine Datei mit einer 
        input_&lt;varname&gt;()-Funktion angelegt. Diese Funktionen holen die 
        Variable aus dem <code>$_REQUEST</code>-Array heraus, setzen sie 
        gegebenenfalls auf den Default-Wert und stellen sicher, dass sie in 
        einem zulässigen Bereich ist. Die Variable <code>$day</code> wird auf 
        den heutigen Tag gesetzt, falls sie nicht gegeben ist.
      </p>
      <source>$day = date("d");</source>
      <p>
        Hat man 'day' jedoch schon gegeben, so gehe ich zu erst sicher, dass 
        es eine integer-Variable ist.
      </p>
      <source>$day = intval(unslashes($_REQUEST['day']));</source>
      <p>
        Danach setzte ich den Tag auf 1 sollte <code>$day</code> kleiner als 1 
        sein und auf 31, sollte <code>$day</code> größer als 31 sein, da es 
        sonst keine möglichen Tage in einem Monat gibt, die genaue Anpassung, 
        z.B. ob es den 31 in dem jeweiligen Monat überhaupt gibt, findet erst 
        später statt.
      </p>
      <source>if($day &lt; 1) $day = 1;
if($day &gt; 31) $day = 31;</source>
      <p>
        Bei dem Monat benutze ich das selbe Vorgehen, bei dem Jahr hingegen 
        bemühe ich mich auch noch die Jahreszahlen in einem sinnvollen Bereich 
        zu halten, so ist keine Jahreszahl kleiner 1970 zugelassen, weil dies 
        den Unix-Timestamp kleiner als 0 machen würde und keine Jahreszahl 
        größer als 2100 zugelassen, da wohl in diesem Jahr niemand mehr 
        Schoorbs/MRBS nutzt. Zum Schluss führe ich noch die oben genannte 
        while-Schleife aus um sicherzustellen, dass nicht Tage wie z.B. 
        31.2. vorkommen. Insgesamt ergibt sich dann folgender Code:
      </p>
      <source>function input_DayMonthYear()
{
  /** day **/ 
  if (!isset($_REQUEST['day'])) {
    $day   = date("d");
  } else {
      $day = intval(unslashes($_REQUEST['day']));
      if($day &lt; 1) $day = 1;
      if($day &gt; 31) $day = 31;
  } 
 
  /** month **/
  if (!isset($_REQUEST['month'])) {
    $month = date('m');
  } else {
    $month = intval(unslashes($_REQUEST['month']));
      if($month &lt; 1) $month = 1;
      if($month &gt; 12) $month = 12;
  }
 
  /** year **/
  if (!isset($_REQUEST['year'])) {
    $year = date("Y");
  } else {
    $year = intval(unslashes($_REQUEST['year']));
      if($year &lt; 1970) $year = 1970; 
      if($year &gt; 2100) $year = 2100; 
  }
 
  // Make the date valid if day is more then 
  // number of days in month
  while (!checkdate($month, $day, $year)) {
    $day--;
  }
 
  return array($day, $month, $year);
}</source>
      <p>
        Dieser Code wird folgendermaßen angewandt:
      </p>
      <source>list($day, $month, $year) = input_DayMonthYear();</source>
    </section>
    <section id="tests">
      <title>Tests</title>
      <p>
        Das Absichern gegen SQL-Injection und XSS-Angriffe war sehr einfach, 
        gegen DoS-Angriffe ist der Schutz jedoch sehr komplex, weshalb ich für 
        die input_&lt;varname&gt;()-Funktionen Tests geschrieben habe. Ich habe 
        für die Test das Unittesting-Framework PHPUnit[12] als Grundlage 
        genommen. Hier werden einzelne Testsektionen als Kindklassen von 
        PHPUnit_Framework_TestCase definiert, ich habe pro Funktion 1 Klasse 
        geschrieben. Wie schon im vorherigen Abschnitt, benutze ich hier die 
        Funktionen input_DayMonthYear() als Beispiel. Insgesamt habe ich 5 
        Testfunktionen geschrieben, die erste überprüft das Verhalten, wenn 
        keine der 3 Variabeln gesetzt ist. Hierzu leere ich sichterheitshalber 
        alle Stellen an denen die Funktion nach day, month oder year suchen 
        könnte(ich suche zwar zur Zeit nur in <code>$_REQUEST</code>, aber die 
        Tests sollen nicht den aktuellen Zustand testen, sondern überprüfen, ob 
        die Spezifikation der Funktion eingehalten wurde):
      </p>
      <source>unset($_GET['day']);
unset($_POST['day']);
unset($_COOKIE['day']);
unset($_REQUEST['day']);
 
unset($_GET['month']);
unset($_POST['month']); 
unset($_COOKIE['month']);
unset($_REQUEST['month']);
 
unset($_GET['year']);
unset($_POST['year']);
unset($_COOKIE['year']);
unset($_REQUEST['year']);</source>
      <p>
        Jetzt rufe ich die Funktion standardmäßig auf und schreibe das Ergebnis 
        in die Variablen <code>$day</code>, <code>$month</code> und 
        <code>$year</code>:
      </p>
      <source>list($day, $month, $year) = input_DayMonthYear();</source>
      <p>
        Nun überprüfe ich mit Hilfe der Funktion <code>assertEquals()</code>, 
        welche man von der Elternklasse geerbt hat, ob das Ergebnis mit der 
        Spezifikation übereinstimmt. Sollte <code>assertEquals()</code> nicht 
        zwei gleiche Variabeln als Parameter bekommen, so schlägt automatisch 
        dieser Test fehl. Laut Spezifikation sollte als Defaultwert immer der 
        heutige Tag genommen werden:
      </p>
      <source>$this->assertEquals(date('d'), $day);
$this->assertEquals(date('m'), $month);
$this->assertEquals(date('Y'), $year);</source>
      <p>
        Nachdem ich nun die Defaultwerte getestet habe, überprüfe ich nun den 
        Mechanismus zum automatischen Anpassen des Tags an die jeweilige 
        Kombination aus Monat und Jahr, ich gebe zum Test den 30.2.2007 ein und 
        möchte als korrigiertes Ergebnis 28.2.2007 haben:
      </p>
      <source>$_REQUEST['day'] = 30;
$_REQUEST['month'] = 2;
$_REQUEST['year'] = 2007;
 
list($day, $month, $year) = input_DayMonthYear();
 
$this->assertEquals(28, $day);
$this->assertEquals(2, $month);
$this->assertEquals(2007, $year);</source>
      <p>
        Als letztes überprüfe ich noch das Verhalten auf Buchstaben in der 
        Eingabe, da dies die Eingabedaten waren, wodurch ich erst auf dieses 
        Problem aufmerksam wurde. Da Buchstaben bei <code>intval()</code> das 
        Ergebnis „0“ erzeugen, erwarte ich hier das mögliche Minimun, also bei 
        Monat und Tag 1, bei Jahr 1970. Hier als Beispiel der Test für das Jahr:
      </p>
      <source>$_REQUEST['day'] = 2;
$_REQUEST['month'] = 2;
$_REQUEST['year'] = 'sgs';
 
list($day, $month, $year) = input_DayMonthYear();
 
$this->assertEquals(2, $day);
$this->assertEquals(2, $month);
$this->assertEquals(1970, $year);</source>
    </section>
    <section id="links">
      <title>Literaturverweise</title>
      <ul>
        <li>
          <strong>[1]</strong> <a href="http://mrbs.sourcforge.net/">Meeting Room 
          Booking System</a>
        </li>
        <li>
          <strong>[2]</strong> MRBS-1.2.5-Quellcode → day.php, Z. 104-107
        </li>
        <li>
          <strong>[3]</strong> 
          <a href="http://de.wikipedia.org/wiki/SQL-Injektion">
            Artikel SQL-Injektion. In: Wikipedia, Die freie Enzyklopädie.  
          </a>
        </li>
        <li>
          <strong>[4]</strong> MRBS-1.2.5-Quellcode → session_php.php, Z. 189-192
        </li>
        <li>
          <strong>[5]</strong>
          <a href="http://de.wikipedia.org/wiki/Cross-Site_Scripting">
            Artikel Cross-Site Scripting. In: Wikipedia, Die freie Enzyklopädie.
          </a>
        </li>
        <li>
          <strong>[6]</strong>
          <a href="http://de.wikipedia.org/wiki/Phishing">
            Artikel Phishing. In: Wikipedia, Die freie Enzyklopädie.
          </a>
        </li>
        <li>
          <strong>[7]</strong>
          <a href="http://php.net/manual/de/ref.info.php#ini.max-execution-time">
            Information über max_execution_time auf php.net
          </a>
        </li>
        <li>
          <strong>[8]</strong>
          <a href="http://de.wikipedia.org/wiki/Denial_of_Service">
            Artikel Denial of Service. In: Wikipedia, Die freie Enzyklopädie.
          </a>
        </li>
        <li>
          <strong>[9]</strong> MRBS-1.2.5-Quellcode → day.php, Z. 13-25
        </li>
        <li>
          <strong>[10]</strong>
          <a href="http://php.net/manual/de/function.mysql-real-escape-string.php">
            mysql_real_escape_string auf php.net
          </a>
        </li>
        <li>
          <strong>[11]</strong>
          <a href="http://php.net/manual/de/function.pg-escape-string.php">
            pg_escape_string auf php.net
          </a>
        </li>
        <li>
          <strong>[12]</strong>
          <a href="http://www.phpunit.de/">
            PHPUnit Testingframework
          </a>
        </li>
      </ul>
      <p class="pageBreakAfter">&nbsp;</p>
    </section>
  </body>
</document>
